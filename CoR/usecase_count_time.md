# Замерить время выполнения алгоритма на сгенерированных данных. Результат записать в txt файле.

1. Реализовать алгоритм (если нет подходящего)
    1. Создать директорию **algo_name** в /algorithms и реализовать там алгоритм.
    2. В /algorithms создать файл **algo_name.py** и унаследовать свой алгоритм от абстрактного класса
       OfflineAlgorithm, подключив реализацию из /algorithms/**algo_name**.
    3. Реализовать 2 разных метода для детекции (detect) и локализации (localize) разладки.
3. Генерация данных
    1. В директории /steps/data_handlers находятся обработчики данных для создания/чтения. Выбираем один из представленных генераторов для синтеза данных.
    2. Если подходящего генератора нет, то:
        1. Создаем файл **generator_name.py** и при необходимости директорию **generator_name** (для более сложной
           реализации)
           в /steps/workers
        2. Наследуемся от интерфейса DataHandler. И реализуем метод write_data. С помощью Storage заполняем
           сгенерированные данные в DataBase.
    3. Для большинства генераторов нужны конфиги (Пример такого конфига normal_normal_config.yaml). Там задаются
       распределения. Первая часть - нормальное распределение длинны 200, матожидание 0.1, среднеквадратичное отклонение
       0.5. Так же задаются все распределения. Все сгенерированные распределения будут соединены в один числовой ряд (отрезок 200 с mean=0.1 и отрезок 200 с mean=0.5)
    4. Далее этот объект генератора будем называть **MyGenerator**.
4. Замер времени
    1. В директории /steps/workers находятся воркеры для исполнения. Одним из таких исполнений может быть замер времени работы алгоритма.
    2. Если есть подходящий воркер, то используем его. Иначе:
        1. Создаем файл **worker_name.py** и при необходимости директорию **worker_name** (для более сложной реализации) в /steps/workers
        2. Наследуемся от интерфейса Worker. И реализуем метод handle. С помощью Storage сохраняем результаты в DataBase
        3. Метод handle в нашем случе ничего не возвращает
    3. Далее объект этого воркера будем называть **TimeWorker**.
5. Обработка результата
    1. В директории /steps/reporters/builders находятся обработчики результатов работы. Выбираем один из представленных
       обработчиков.
    2. Если подходящего Билдера нет, то:
        1. Создаем файл **builder_name.py** и при необходимости директорию **builder_name** (для более сложной
           реализации) в /steps/reporters/builders
        2. Наследуемся от интерфейса ReportBuilder. И реализуем метод build. Он записывает нужную информацию в свои
           поля (замеры времени)
    3. В директории /steps/reporters/visualizers находятся Визуализаторы обработанных результатов. Выбираем один из
       представленных Визуализаторов.
    4. Если подходящего Визуализатора нет, то:
        1. Создаем файл **visualizer_name.py** и при необходимости директорию **visualizer_name** (для более сложной
           реализации) в /steps/reporters/visualizers
        2. Наследуемся от интерфейса ReportVisualizer. И реализуем метод draw для отрисовки и сохранения результата в txt.
    5. Далее этот объект репортера будем называть **TxtReporter**.
6. Оценить качество
    1. Создаем конфиг для генерации большего количества датасетов с нужными распределением.
    2. Создаем DataGenerationStep (name=**MyGenerationStep**). Туда передается **MyGenerator** и Storage (туда
       будут сохраняться данные).
    3. Так же заполняем поля _input_data_names_ (None) и _output_data_names_ (названия параметров, по которым данные
       записываются в БД). В нашем случае _input_data_names_ = None,
       _output_data_names_ = ['TIME_SERIES']
    4. Создаем первый ExecutionStep (name=**TimeStep**). Он будет подбирать мета-параметры и передавать их в
       следующий шаг. Необходимо указать _input_data_names_, _output_data_names_. Соответственно ['TIME_SERIES'], None, ['THRESHOLD']. Передаем **TimeWorker**.
    6. Создаем ReportGenerationStep (name=**TxtReportStep**). Необходимо указать _input_data_names_,
       _output_data_names_. Соответственно ['EXECUTION_TIME'], []. И передать
       **TxtReporter**.
    7. Передаем все вышеперечисленные шаги в pipeline. При запуске получаем вывод:
        - MyGenerationStep: OK
        - TimeStep: OK
        - TxtReporter: OK
        - PIPELINE FINISHED