# Реализовать алгоритм поиска разладки, сгенерировать данные по конфигу, запустить и выдать время работы в txt файле

1. Реализовать алгоритм (**Программист**)
    1. Создать директорию **algo_name** в /algorithms и реализовать там алгоритм.
    2. В /algorithms создать файл **algo_name.py** и унаследовать свой алгоритм от абстрактного класса OfflineAlgorithm, подключив реализацию из /algorithms/**algo_name**.
    3. Реализовать 2 разных метода для детекции (detect) и локализации (localize) разладки.
2. Генерация данных (**Юзер**)
    1. Из директории /steps/data_generation_step импортируем **step** для нормального распределения
    2. Пишем конфиг для распределения (например, normal_normal_config.yaml)
3. Обработка результата (**Программист**)
    1. Создаем директорию **report_builder_name** в /steps/report_generation_step/reporters
    2. Наследуемся от интерфейса ReportBuilder. И реализуем нашу логику и метод build. Он записывает нужную информацию в свои поля (время)
    3. Создаем директорию **report_visualizer_name** в /steps/report_generation_step/visualizers
    4. Наследуемся от интерфейса ReportVisualizer. И реализуем метод draw для записывания результатов в txt.
4. Создание Пайплайна (**Юзер**)
    1. В pipline создаем скрипт, инициализируем pipeline, 
    2. Передаем туда генератор, указав конфиг и _input_data_names = None, output_data_names = [поля]_
    3. Инициализируем созданный алгоритм параметрами, указываем _input_data_names=[поля], output_data_names=[поля результата]_
    4. Передаем в пайплайн созданный репортр визуализатор, _input_data_names=[поля результата], output_data_names=None_
    5. Запускаем пайплайн, получаем сообщения о ходе работы
5. Получение результатов и анализ (**Юзер**)
    1. В /results сохранится результат работы
    2. Открываем файл и видим результат
