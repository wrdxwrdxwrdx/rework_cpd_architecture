# Добавить реализацию СКРАБИРУЮЩЕГО algo_name алгоритма в CPD библиотеку.

1. Реализовать алгоритм
   1. Создать файл **algo_name** в директории /algorithms.
   2. Реализовать алгоритм, унаследовав его от _OfflineAlgorithm_
2. Генератор данных
   1. Если нужного генератора нет
      1. В директории /data_generators создать **gen_name**
      2. Написать генератор, унаследовав класс _Generator_
3. Создание репортера
   1. Если нужного репортера нет
      1. В директории /reporters создать **reporter_name**
      2. Написать репортбилдер и репортвизуализатор
      3. Написать репортер, использовав репортбилдер и репортвизуализатор
4. Создание воркера
   1. В директории /workers создать **worker_name**
   2. Реализовать в нём нужную функциональность, связанную с algo_name
5. Создание фабрики
   1. В директории /absfactories создать файл и реализовать в нём класс _AlgoFactory_, унаследовав его от _AbstractFactory_
   2. Реализовать методы _createGenerator()_, _createWorker()_, _createReporter()_, которые будут возвращать нужные объекты с заданными гиперпараметрами
   3. Передача данных между стадиями будет осуществляться через общие поля в объекте фабрики 
   (!) Непонятно как проверять наличие или отсутствия данных между шагами. Например откуда мы знаем, что после работы алгоритма сохранится время его работы, нужное для передачи в репортер. Эта задача ложится на плечи программиста.
6. Использование
   1. Создать объект _AlgoFactory_, передав нужные гиперпараметры
   2. Вызвать фабричные методы и получить инициализированные объекты
   3. Вызвать методы для запуска и получить готовый результат

(!) Такая архитектура кажется мне очень неповоротливой, поскольку даже при самом малом изменении одного из степов придётся переписывать или реализовывать с нуля вообще всю фабрику.