# Добавить реализацию СКРАБИРУЮЩЕГО algo_name алгоритма в CPD библиотеку.

1. Реализовать алгоритм
   1. Создать директорию **algo_name** в /algorithms.
   2. Реализовать алгоритм, унаследовав его от _OfflineAlgorithm_
2. Генератор данных
   1. Если нужного генератора нет
      1. В /data_generators создать директорию **gen_name**
      2. Написать генератор, унаследовав класс _Generator_
3. Создание репортера
   1. Если нужного репортера нет
      1. В /reporters создать директорию **reporter_name**
      2. Написать репортбилдер и репортвизуализатор
      3. Написать репортер, использовав репортбилдер и репортвизуализатор
4. Создание воркера
   1. В /workers создать директорию **worker_name**
   2. Реализовать подбор метапараметров для algo_name
5. Создание фабрики
   1. В /absfactories создать директорию и реализовать в ней класс _AlgoFactory_, унаследовав его от _AbstractFactory_
   2. Реализовать методы _createGenerator()_, _createWorker()_, _createReporter()_, которые будут возвращать нужные объекты с заданными гиперпараметрами
   3. Передача данных между стадиями будет осуществляться через общие поля в объекте фабрики 
   (!) Непонятно как проверять наличие или отсутствия данных между шагами. Например откуда мы знаем, что после работы алгоритма сохранится время его работы, нужное для передачи в репортер. Эта задача ложится на плечи программиста.
6. Использование
   1. Создать объект _AlgoFactory_, передав нужные гиперпараметры
   2. Вызвать фабричные методы и получить инициализированные объекты
   3. Вызвать методы для запуска и получить готовый результат

(!) Такая архитектура кажется мне очень неповоротливой, поскольку даже при самом малом изменении одного из степов придётся переписывать или реализовывать с нуля вообще всю фабрику.